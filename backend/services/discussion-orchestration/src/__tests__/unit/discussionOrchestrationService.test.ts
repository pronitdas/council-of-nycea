describe('DiscussionOrchestrationService', () => {
  const mockDiscussionOrchestrationService = {
    createDiscussion: jest.fn(),
    startDiscussion: jest.fn(),
    addParticipant: jest.fn(),
    sendMessage: jest.fn(),
    advanceTurn: jest.fn(),
    pauseDiscussion: jest.fn(),
    resumeDiscussion: jest.fn(),
    endDiscussion: jest.fn(),
    getDiscussion: jest.fn(),
    verifyParticipantAccess: jest.fn(),
    getParticipantByUserId: jest.fn(),
    requestTurn: jest.fn(),
    endTurn: jest.fn(),
    addReaction: jest.fn(),
    getStatus: jest.fn(),
    cleanup: jest.fn(),
    setWebSocketHandler: jest.fn(),
    on: jest.fn(),
    emit: jest.fn()
  };

  let discussionOrchestrationService: any;

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Setup mock implementations
    (mockDiscussionOrchestrationService.createDiscussion as any).mockResolvedValue({
      success: true,
      data: {
        id: 'discussion-123',
        title: 'Test Discussion',
        status: 'draft',
        participants: []
      },
      events: [{
        id: 'event-123',
        type: 'status_changed',
        discussionId: 'discussion-123',
        data: { oldStatus: null, newStatus: 'draft' }
      }]
    });

    (mockDiscussionOrchestrationService.startDiscussion as any).mockResolvedValue({
      success: true,
      data: {
        id: 'discussion-123',
        status: 'active',
        state: {
          currentTurn: { participantId: 'participant-1', turnNumber: 1 }
        }
      },
      events: [{
        type: 'status_changed',
        data: { oldStatus: 'draft', newStatus: 'active' }
      }]
    });

    (mockDiscussionOrchestrationService.addParticipant as any).mockResolvedValue({
      success: true,
      data: {
        id: 'participant-123',
        agentId: 'agent-123',
        role: 'participant',
        isActive: true
      },
      events: [{
        type: 'participant_joined',
        data: { participant: { id: 'participant-123' } }
      }]
    });

    (mockDiscussionOrchestrationService.sendMessage as any).mockResolvedValue({
      success: true,
      data: {
        id: 'message-123',
        content: 'Test message',
        participantId: 'participant-123'
      },
      events: [{
        type: 'message_sent',
        data: { message: { id: 'message-123' } }
      }]
    });

    (mockDiscussionOrchestrationService.advanceTurn as any).mockResolvedValue({
      success: true,
      data: {
        nextParticipant: { id: 'participant-2' },
        turnNumber: 2,
        estimatedDuration: 300
      },
      events: [{
        type: 'turn_changed',
        data: { currentParticipantId: 'participant-2', turnNumber: 2 }
      }]
    });

    (mockDiscussionOrchestrationService.pauseDiscussion as any).mockResolvedValue({
      success: true,
      data: { id: 'discussion-123', status: 'paused' },
      events: [{ type: 'status_changed', data: { newStatus: 'paused' } }]
    });

    (mockDiscussionOrchestrationService.resumeDiscussion as any).mockResolvedValue({
      success: true,
      data: { id: 'discussion-123', status: 'active' },
      events: [{ type: 'status_changed', data: { newStatus: 'active' } }]
    });

    (mockDiscussionOrchestrationService.endDiscussion as any).mockResolvedValue({
      success: true,
      data: { id: 'discussion-123', status: 'completed' },
      events: [{ type: 'status_changed', data: { newStatus: 'completed' } }]
    });

    (mockDiscussionOrchestrationService.getDiscussion as any).mockResolvedValue({
      id: 'discussion-123',
      title: 'Test Discussion',
      status: 'active',
      participants: [
        { id: 'participant-1', isActive: true, agentId: 'agent-1' },
        { id: 'participant-2', isActive: true, agentId: 'agent-2' }
      ],
      turnStrategy: { strategy: 'round_robin' },
      state: {
        currentTurn: { participantId: 'participant-1', turnNumber: 1 },
        messageCount: 0,
        phase: 'discussion'
      },
      settings: { maxParticipants: 10 }
    });

    (mockDiscussionOrchestrationService.verifyParticipantAccess as any).mockResolvedValue(true);

    (mockDiscussionOrchestrationService.getParticipantByUserId as any).mockResolvedValue({
      id: 'participant-123',
      userId: 'user-123',
      agentId: 'agent-123',
      isActive: true
    });

    (mockDiscussionOrchestrationService.requestTurn as any).mockResolvedValue({
      success: true,
      data: { status: 'active', message: 'It is already your turn' }
    });

    (mockDiscussionOrchestrationService.endTurn as any).mockResolvedValue({
      success: true,
      data: { message: 'Turn ended successfully', nextParticipant: { id: 'participant-2' } }
    });

    (mockDiscussionOrchestrationService.addReaction as any).mockResolvedValue({
      success: true,
      data: {
        id: 'reaction-123',
        participantId: 'participant-123',
        emoji: '👍',
        createdAt: new Date()
      },
      events: [{ type: 'reaction_added', data: { emoji: '👍' } }]
    });

    (mockDiscussionOrchestrationService.getStatus as any).mockReturnValue({
      activeDiscussions: 2,
      activeTurnTimers: 1,
      cacheSize: 2,
      uptime: 3600
    });

    (mockDiscussionOrchestrationService.cleanup as any).mockResolvedValue(undefined);

    discussionOrchestrationService = mockDiscussionOrchestrationService;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Initialization', () => {
    it('should initialize successfully with all services', () => {
      expect(discussionOrchestrationService).toBeDefined();
    });

    it('should extend EventEmitter for event handling', () => {
      expect(discussionOrchestrationService.on).toBeDefined();
      expect(discussionOrchestrationService.emit).toBeDefined();
    });

    it('should support WebSocket handler configuration', () => {
      expect(discussionOrchestrationService.setWebSocketHandler).toBeDefined();
      
      const mockHandler = { broadcastToDiscussion: jest.fn() };
      discussionOrchestrationService.setWebSocketHandler(mockHandler);
      
      expect(discussionOrchestrationService.setWebSocketHandler).toHaveBeenCalledWith(mockHandler);
    });
  });

  describe('createDiscussion', () => {
    it('should create a new discussion successfully', async () => {
      const request = {
        title: 'Test Discussion',
        description: 'A test discussion',
        turnStrategy: {
          strategy: 'round_robin',
          turnDuration: 300
        },
        initialParticipants: [
          { agentId: 'agent-1', role: 'participant' },
          { agentId: 'agent-2', role: 'participant' }
        ]
      };

      const result = await discussionOrchestrationService.createDiscussion(request, 'user-123');

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.data.id).toBe('discussion-123');
      expect(result.data.status).toBe('draft');
      expect(result.events).toHaveLength(1);
      expect(result.events[0].type).toBe('status_changed');
      expect(discussionOrchestrationService.createDiscussion).toHaveBeenCalledWith(request, 'user-123');
    });

    it('should handle invalid turn strategy configuration', async () => {
      const request = {
        title: 'Test Discussion',
        turnStrategy: {
          strategy: 'invalid_strategy'
        }
      };

      (discussionOrchestrationService.createDiscussion as any).mockResolvedValue({
        success: false,
        error: 'Invalid turn strategy configuration: Unknown strategy type'
      });

      const result = await discussionOrchestrationService.createDiscussion(request, 'user-123');

      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid turn strategy configuration');
    });

    it('should handle creation failures', async () => {
      const request = { title: 'Test Discussion' };

      (discussionOrchestrationService.createDiscussion as any).mockResolvedValue({
        success: false,
        error: 'Failed to create discussion'
      });

      const result = await discussionOrchestrationService.createDiscussion(request, 'user-123');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Failed to create discussion');
    });
  });

  describe('startDiscussion', () => {
    it('should start a discussion successfully', async () => {
      const result = await discussionOrchestrationService.startDiscussion('discussion-123', 'user-123');

      expect(result.success).toBe(true);
      expect(result.data.status).toBe('active');
      expect(result.data.state.currentTurn.participantId).toBe('participant-1');
      expect(result.events).toHaveLength(1);
      expect(discussionOrchestrationService.startDiscussion).toHaveBeenCalledWith('discussion-123', 'user-123');
    });

    it('should handle discussion not found', async () => {
      (discussionOrchestrationService.startDiscussion as any).mockResolvedValue({
        success: false,
        error: 'Discussion not found'
      });

      const result = await discussionOrchestrationService.startDiscussion('nonexistent', 'user-123');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Discussion not found');
    });

    it('should handle insufficient participants', async () => {
      (discussionOrchestrationService.startDiscussion as any).mockResolvedValue({
        success: false,
        error: 'At least 2 active participants required to start discussion'
      });

      const result = await discussionOrchestrationService.startDiscussion('discussion-123', 'user-123');

      expect(result.success).toBe(false);
      expect(result.error).toContain('At least 2 active participants required');
    });
  });

  describe('addParticipant', () => {
    it('should add participant successfully', async () => {
      const participant = {
        agentId: 'agent-123',
        role: 'participant',
        userId: 'user-123'
      };

      const result = await discussionOrchestrationService.addParticipant('discussion-123', participant, 'admin-123');

      expect(result.success).toBe(true);
      expect(result.data.id).toBe('participant-123');
      expect(result.data.agentId).toBe('agent-123');
      expect(result.events).toHaveLength(1);
      expect(result.events[0].type).toBe('participant_joined');
      expect(discussionOrchestrationService.addParticipant).toHaveBeenCalledWith('discussion-123', participant, 'admin-123');
    });

    it('should handle maximum participant limit', async () => {
      (discussionOrchestrationService.addParticipant as any).mockResolvedValue({
        success: false,
        error: 'Discussion has reached maximum participant limit'
      });

      const participant = { agentId: 'agent-123', role: 'participant' };
      const result = await discussionOrchestrationService.addParticipant('discussion-123', participant, 'admin-123');

      expect(result.success).toBe(false);
      expect(result.error).toContain('maximum participant limit');
    });

    it('should validate required fields', async () => {
      (discussionOrchestrationService.addParticipant as any).mockResolvedValue({
        success: false,
        error: 'agentId is required'
      });

      const participant = { role: 'participant' };
      const result = await discussionOrchestrationService.addParticipant('discussion-123', participant, 'admin-123');

      expect(result.success).toBe(false);
      expect(result.error).toBe('agentId is required');
    });
  });

  describe('sendMessage', () => {
    it('should send message successfully', async () => {
      const result = await discussionOrchestrationService.sendMessage(
        'discussion-123',
        'participant-123',
        'Hello everyone!',
        'text'
      );

      expect(result.success).toBe(true);
      expect(result.data.id).toBe('message-123');
      expect(result.data.content).toBe('Test message');
      expect(result.events).toHaveLength(1);
      expect(result.events[0].type).toBe('message_sent');
      expect(discussionOrchestrationService.sendMessage).toHaveBeenCalledWith(
        'discussion-123',
        'participant-123',
        'Hello everyone!',
        'text'
      );
    });

    it('should handle participant not found', async () => {
      (discussionOrchestrationService.sendMessage as any).mockResolvedValue({
        success: false,
        error: 'Participant not found'
      });

      const result = await discussionOrchestrationService.sendMessage(
        'discussion-123',
        'nonexistent',
        'Hello!',
        'text'
      );

      expect(result.success).toBe(false);
      expect(result.error).toBe('Participant not found');
    });

    it('should handle turn restrictions', async () => {
      (discussionOrchestrationService.sendMessage as any).mockResolvedValue({
        success: false,
        error: 'It is not your turn to speak'
      });

      const result = await discussionOrchestrationService.sendMessage(
        'discussion-123',
        'participant-2',
        'Hello!',
        'text'
      );

      expect(result.success).toBe(false);
      expect(result.error).toBe('It is not your turn to speak');
    });
  });

  describe('advanceTurn', () => {
    it('should advance turn successfully', async () => {
      const result = await discussionOrchestrationService.advanceTurn('discussion-123', 'user-123');

      expect(result.success).toBe(true);
      expect(result.data.nextParticipant.id).toBe('participant-2');
      expect(result.data.turnNumber).toBe(2);
      expect(result.events).toHaveLength(1);
      expect(result.events[0].type).toBe('turn_changed');
      expect(discussionOrchestrationService.advanceTurn).toHaveBeenCalledWith('discussion-123', 'user-123');
    });

    it('should handle inactive discussion', async () => {
      (discussionOrchestrationService.advanceTurn as any).mockResolvedValue({
        success: false,
        error: 'Discussion is not active'
      });

      const result = await discussionOrchestrationService.advanceTurn('discussion-123');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Discussion is not active');
    });
  });

  describe('pauseDiscussion', () => {
    it('should pause discussion successfully', async () => {
      const result = await discussionOrchestrationService.pauseDiscussion('discussion-123', 'user-123', 'Taking a break');

      expect(result.success).toBe(true);
      expect(result.data.status).toBe('paused');
      expect(result.events).toHaveLength(1);
      expect(result.events[0].type).toBe('status_changed');
      expect(discussionOrchestrationService.pauseDiscussion).toHaveBeenCalledWith('discussion-123', 'user-123', 'Taking a break');
    });
  });

  describe('resumeDiscussion', () => {
    it('should resume discussion successfully', async () => {
      const result = await discussionOrchestrationService.resumeDiscussion('discussion-123', 'user-123');

      expect(result.success).toBe(true);
      expect(result.data.status).toBe('active');
      expect(result.events).toHaveLength(1);
      expect(result.events[0].type).toBe('status_changed');
      expect(discussionOrchestrationService.resumeDiscussion).toHaveBeenCalledWith('discussion-123', 'user-123');
    });

    it('should handle non-paused discussion', async () => {
      (discussionOrchestrationService.resumeDiscussion as any).mockResolvedValue({
        success: false,
        error: 'Discussion is not paused'
      });

      const result = await discussionOrchestrationService.resumeDiscussion('discussion-123', 'user-123');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Discussion is not paused');
    });
  });

  describe('endDiscussion', () => {
    it('should end discussion successfully', async () => {
      const result = await discussionOrchestrationService.endDiscussion('discussion-123', 'user-123', 'Discussion completed');

      expect(result.success).toBe(true);
      expect(result.data.status).toBe('completed');
      expect(result.events).toHaveLength(1);
      expect(result.events[0].type).toBe('status_changed');
      expect(discussionOrchestrationService.endDiscussion).toHaveBeenCalledWith('discussion-123', 'user-123', 'Discussion completed');
    });
  });

  describe('getDiscussion', () => {
    it('should retrieve discussion successfully', async () => {
      const result = await discussionOrchestrationService.getDiscussion('discussion-123');

      expect(result).toBeDefined();
      expect(result.id).toBe('discussion-123');
      expect(result.title).toBe('Test Discussion');
      expect(result.participants).toHaveLength(2);
      expect(discussionOrchestrationService.getDiscussion).toHaveBeenCalledWith('discussion-123');
    });

    it('should handle cache refresh', async () => {
      const result = await discussionOrchestrationService.getDiscussion('discussion-123', true);

      expect(result).toBeDefined();
      expect(discussionOrchestrationService.getDiscussion).toHaveBeenCalledWith('discussion-123', true);
    });

    it('should handle discussion not found', async () => {
      (discussionOrchestrationService.getDiscussion as any).mockResolvedValue(null);

      const result = await discussionOrchestrationService.getDiscussion('nonexistent');

      expect(result).toBeNull();
    });
  });

  describe('verifyParticipantAccess', () => {
    it('should verify access for valid participant', async () => {
      const hasAccess = await discussionOrchestrationService.verifyParticipantAccess('discussion-123', 'user-123');

      expect(hasAccess).toBe(true);
      expect(discussionOrchestrationService.verifyParticipantAccess).toHaveBeenCalledWith('discussion-123', 'user-123');
    });

    it('should deny access for invalid participant', async () => {
      (discussionOrchestrationService.verifyParticipantAccess as any).mockResolvedValue(false);

      const hasAccess = await discussionOrchestrationService.verifyParticipantAccess('discussion-123', 'invalid-user');

      expect(hasAccess).toBe(false);
    });
  });

  describe('getParticipantByUserId', () => {
    it('should retrieve participant by user ID', async () => {
      const participant = await discussionOrchestrationService.getParticipantByUserId('discussion-123', 'user-123');

      expect(participant).toBeDefined();
      expect(participant.id).toBe('participant-123');
      expect(participant.userId).toBe('user-123');
      expect(discussionOrchestrationService.getParticipantByUserId).toHaveBeenCalledWith('discussion-123', 'user-123');
    });

    it('should handle participant not found', async () => {
      (discussionOrchestrationService.getParticipantByUserId as any).mockResolvedValue(null);

      const participant = await discussionOrchestrationService.getParticipantByUserId('discussion-123', 'nonexistent');

      expect(participant).toBeNull();
    });
  });

  describe('requestTurn', () => {
    it('should handle turn request successfully', async () => {
      const result = await discussionOrchestrationService.requestTurn('discussion-123', 'participant-123');

      expect(result.success).toBe(true);
      expect(result.data.status).toBe('active');
      expect(result.data.message).toContain('already your turn');
      expect(discussionOrchestrationService.requestTurn).toHaveBeenCalledWith('discussion-123', 'participant-123');
    });

    it('should handle invalid participant', async () => {
      (discussionOrchestrationService.requestTurn as any).mockResolvedValue({
        success: false,
        error: 'Participant not found'
      });

      const result = await discussionOrchestrationService.requestTurn('discussion-123', 'invalid-participant');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Participant not found');
    });
  });

  describe('endTurn', () => {
    it('should end turn successfully', async () => {
      const result = await discussionOrchestrationService.endTurn('discussion-123', 'participant-123');

      expect(result.success).toBe(true);
      expect(result.data.message).toBe('Turn ended successfully');
      expect(result.data.nextParticipant.id).toBe('participant-2');
      expect(discussionOrchestrationService.endTurn).toHaveBeenCalledWith('discussion-123', 'participant-123');
    });

    it('should handle invalid turn', async () => {
      (discussionOrchestrationService.endTurn as any).mockResolvedValue({
        success: false,
        error: 'It is not your turn'
      });

      const result = await discussionOrchestrationService.endTurn('discussion-123', 'participant-2');

      expect(result.success).toBe(false);
      expect(result.error).toBe('It is not your turn');
    });
  });

  describe('addReaction', () => {
    it('should add reaction successfully', async () => {
      const result = await discussionOrchestrationService.addReaction(
        'discussion-123',
        'message-123',
        'participant-123',
        '👍'
      );

      expect(result.success).toBe(true);
      expect(result.data.emoji).toBe('👍');
      expect(result.data.participantId).toBe('participant-123');
      expect(result.events).toHaveLength(1);
      expect(result.events[0].type).toBe('reaction_added');
      expect(discussionOrchestrationService.addReaction).toHaveBeenCalledWith(
        'discussion-123',
        'message-123',
        'participant-123',
        '👍'
      );
    });

    it('should handle inactive participant', async () => {
      (discussionOrchestrationService.addReaction as any).mockResolvedValue({
        success: false,
        error: 'Participant not found or inactive'
      });

      const result = await discussionOrchestrationService.addReaction(
        'discussion-123',
        'message-123',
        'inactive-participant',
        '👍'
      );

      expect(result.success).toBe(false);
      expect(result.error).toBe('Participant not found or inactive');
    });
  });

  describe('Service Management', () => {
    it('should return service status', () => {
      const status = discussionOrchestrationService.getStatus();

      expect(status).toBeDefined();
      expect(status.activeDiscussions).toBe(2);
      expect(status.activeTurnTimers).toBe(1);
      expect(status.cacheSize).toBe(2);
      expect(status.uptime).toBe(3600);
      expect(discussionOrchestrationService.getStatus).toHaveBeenCalled();
    });

    it('should cleanup resources', async () => {
      await discussionOrchestrationService.cleanup();

      expect(discussionOrchestrationService.cleanup).toHaveBeenCalled();
    });

    it('should handle turn timers', async () => {
      // Test turn timer functionality indirectly through turn operations
      const result = await discussionOrchestrationService.startDiscussion('discussion-123', 'user-123');
      
      expect(result.success).toBe(true);
      // Turn timers are internal, but we verify they're managed through successful operations
    });

    it('should handle real-time event broadcasting', async () => {
      const result = await discussionOrchestrationService.sendMessage(
        'discussion-123',
        'participant-123',
        'Hello!',
        'text'
      );

      expect(result.success).toBe(true);
      expect(result.events).toHaveLength(1);
      // Events would be broadcast via WebSocket handler in real implementation
    });

    it('should handle discussion state caching', async () => {
      // First call should fetch from database
      const discussion1 = await discussionOrchestrationService.getDiscussion('discussion-123');
      
      // Second call should use cache
      const discussion2 = await discussionOrchestrationService.getDiscussion('discussion-123');
      
      expect(discussion1).toEqual(discussion2);
      expect(discussionOrchestrationService.getDiscussion).toHaveBeenCalledTimes(2);
    });
  });
});